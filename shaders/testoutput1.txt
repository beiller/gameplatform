1: precision highp float;
2: precision highp int;
3: #define SHADER_NAME ShaderMaterial
4: #define VERTEX_TEXTURES
5: #define GAMMA_FACTOR 2
6: #define MAX_DIR_LIGHTS 2
7: #define MAX_POINT_LIGHTS 0
8: #define MAX_SPOT_LIGHTS 0
9: #define MAX_HEMI_LIGHTS 0
10: #define MAX_SHADOWS 0
11: #define MAX_BONES 1024
12: #define USE_SKINNING
13: #define BONE_TEXTURE
14: uniform mat4 modelMatrix;
15: uniform mat4 modelViewMatrix;
16: uniform mat4 projectionMatrix;
17: uniform mat4 viewMatrix;
18: uniform mat3 normalMatrix;
19: uniform vec3 cameraPosition;
20: attribute vec3 position;
21: attribute vec3 normal;
22: attribute vec2 uv;
23: #ifdef USE_COLOR
24: 	attribute vec3 color;
25: #endif
26: #ifdef USE_MORPHTARGETS
27: 	attribute vec3 morphTarget0;
28: 	attribute vec3 morphTarget1;
29: 	attribute vec3 morphTarget2;
30: 	attribute vec3 morphTarget3;
31: 	#ifdef USE_MORPHNORMALS
32: 		attribute vec3 morphNormal0;
33: 		attribute vec3 morphNormal1;
34: 		attribute vec3 morphNormal2;
35: 		attribute vec3 morphNormal3;
36: 	#else
37: 		attribute vec3 morphTarget4;
38: 		attribute vec3 morphTarget5;
39: 		attribute vec3 morphTarget6;
40: 		attribute vec3 morphTarget7;
41: 	#endif
42: #endif
43: #ifdef USE_SKINNING
44: 	attribute vec4 skinIndex;
45: 	attribute vec4 skinWeight;
46: #endif
47: 
48: #define PHONG
49: varying vec3 vViewPosition;
50: #ifndef FLAT_SHADED
51: 	varying vec3 vNormal;
52: #endif
53: varying vec2 vUv;
54: #define PI 3.14159
55: #define PI2 6.28318
56: #define RECIPROCAL_PI2 0.15915494
57: #define LOG2 1.442695
58: #define EPSILON 1e-6
59: 
60: #define saturate(a) clamp( a, 0.0, 1.0 )
61: #define whiteCompliment(a) ( 1.0 - saturate( a ) )
62: 
63: vec3 transformDirection( in vec3 normal, in mat4 matrix ) {
64: 
65: 	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );
66: 
67: }
68: 
69: vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {
70: 
71: 	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );
72: 
73: }
74: 
75: vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
76: 
77: 	float distance = dot( planeNormal, point - pointOnPlane );
78: 
79: 	return - distance * planeNormal + point;
80: 
81: }
82: 
83: float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
84: 
85: 	return sign( dot( point - pointOnPlane, planeNormal ) );
86: 
87: }
88: 
89: vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
90: 
91: 	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
92: 
93: }
94: 
95: float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {
96: 
97: 	if ( decayExponent > 0.0 ) {
98: 
99: 	  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
100: 
101: 	}
102: 
103: 	return 1.0;
104: 
105: }
106: 
107: vec3 F_Schlick( in vec3 specularColor, in float dotLH ) {
108: 
109: 
110: 	float fresnel = exp2( ( -5.55437 * dotLH - 6.98316 ) * dotLH );
111: 
112: 	return ( 1.0 - specularColor ) * fresnel + specularColor;
113: 
114: }
115: 
116: float G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {
117: 
118: 
119: 	return 0.25;
120: 
121: }
122: 
123: float D_BlinnPhong( in float shininess, in float dotNH ) {
124: 
125: 
126: 	return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
127: 
128: }
129: 
130: vec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {
131: 
132: 	vec3 halfDir = normalize( lightDir + viewDir );
133: 
134: 	float dotNH = saturate( dot( normal, halfDir ) );
135: 	float dotLH = saturate( dot( lightDir, halfDir ) );
136: 
137: 	vec3 F = F_Schlick( specularColor, dotLH );
138: 
139: 	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );
140: 
141: 	float D = D_BlinnPhong( shininess, dotNH );
142: 
143: 	return F * G * D;
144: 
145: }
146: 
147: vec3 inputToLinear( in vec3 a ) {
148: 
149: 	#ifdef GAMMA_INPUT
150: 
151: 		return pow( a, vec3( float( GAMMA_FACTOR ) ) );
152: 
153: 	#else
154: 
155: 		return a;
156: 
157: 	#endif
158: 
159: }
160: 
161: vec3 linearToOutput( in vec3 a ) {
162: 
163: 	#ifdef GAMMA_OUTPUT
164: 
165: 		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );
166: 
167: 	#else
168: 
169: 		return a;
170: 
171: 	#endif
172: 
173: }
174: 
175: #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )
176: 
177: 	varying vec2 vUv;
178: 	uniform vec4 offsetRepeat;
179: 
180: #endif
181: 
182: #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
183: 
184: 	attribute vec2 uv2;
185: 	varying vec2 vUv2;
186: 
187: #endif
188: #ifdef USE_DISPLACEMENTMAP
189: 
190: 	uniform sampler2D displacementMap;
191: 	uniform float displacementScale;
192: 	uniform float displacementBias;
193: 
194: #endif
195: 
196: #if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )
197: 
198: 	varying vec3 vReflect;
199: 
200: 	uniform float refractionRatio;
201: 
202: #endif
203: 
204: #if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )
205: 
206: 	varying vec3 vWorldPosition;
207: 
208: #endif
209: 
210: #if MAX_POINT_LIGHTS > 0
211: 
212: 	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];
213: 
214: #endif
215: 
216: #ifdef USE_COLOR
217: 
218: 	varying vec3 vColor;
219: 
220: #endif
221: #ifdef USE_MORPHTARGETS
222: 
223: 	#ifndef USE_MORPHNORMALS
224: 
225: 	uniform float morphTargetInfluences[ 8 ];
226: 
227: 	#else
228: 
229: 	uniform float morphTargetInfluences[ 4 ];
230: 
231: 	#endif
232: 
233: #endif
234: #ifdef USE_SKINNING
235: 
236: 	uniform mat4 bindMatrix;
237: 	uniform mat4 bindMatrixInverse;
238: 
239: 	#ifdef BONE_TEXTURE
240: 
241: 		uniform sampler2D boneTexture;
242: 		uniform int boneTextureWidth;
243: 		uniform int boneTextureHeight;
244: 
245: 		mat4 getBoneMatrix( const in float i ) {
246: 
247: 			float j = i * 4.0;
248: 			float x = mod( j, float( boneTextureWidth ) );
249: 			float y = floor( j / float( boneTextureWidth ) );
250: 
251: 			float dx = 1.0 / float( boneTextureWidth );
252: 			float dy = 1.0 / float( boneTextureHeight );
253: 
254: 			y = dy * ( y + 0.5 );
255: 
256: 			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
257: 			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
258: 			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
259: 			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
260: 
261: 			mat4 bone = mat4( v1, v2, v3, v4 );
262: 
263: 			return bone;
264: 
265: 		}
266: 
267: 	#else
268: 
269: 		uniform mat4 boneGlobalMatrices[ MAX_BONES ];
270: 
271: 		mat4 getBoneMatrix( const in float i ) {
272: 
273: 			mat4 bone = boneGlobalMatrices[ int(i) ];
274: 			return bone;
275: 
276: 		}
277: 
278: 	#endif
279: 
280: #endif
281: 
282: #ifdef USE_SHADOWMAP
283: 
284: 	uniform float shadowDarkness[ MAX_SHADOWS ];
285: 	uniform mat4 shadowMatrix[ MAX_SHADOWS ];
286: 	varying vec4 vShadowCoord[ MAX_SHADOWS ];
287: 
288: #endif
289: #ifdef USE_LOGDEPTHBUF
290: 
291: 	#ifdef USE_LOGDEPTHBUF_EXT
292: 
293: 		varying float vFragDepth;
294: 
295: 	#endif
296: 
297: 	uniform float logDepthBufFC;
298: 
299: #endif
300: void main() {
301: #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP )
302: 
303: 	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;
304: 
305: #endif
306: #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
307: 
308: 	vUv2 = uv2;
309: 
310: #endif
311: #ifdef USE_COLOR
312: 
313: 	vColor.xyz = color.xyz;
314: 
315: #endif
316: 
317: vec3 objectNormal = vec3( normal );
318: 
319: #ifdef USE_MORPHNORMALS
320: 
321: 	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
322: 	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
323: 	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
324: 	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];
325: 
326: #endif
327: 
328: #ifdef USE_SKINNING
329: 
330: 	mat4 boneMatX = getBoneMatrix( skinIndex.x );
331: 	mat4 boneMatY = getBoneMatrix( skinIndex.y );
332: 	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
333: 	mat4 boneMatW = getBoneMatrix( skinIndex.w );
334: 
335: #endif
336: #ifdef USE_SKINNING
337: 
338: 	mat4 skinMatrix = mat4( 0.0 );
339: 	skinMatrix += skinWeight.x * boneMatX;
340: 	skinMatrix += skinWeight.y * boneMatY;
341: 	skinMatrix += skinWeight.z * boneMatZ;
342: 	skinMatrix += skinWeight.w * boneMatW;
343: 	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;
344: 
345: 	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
346: 
347: #endif
348: 
349: #ifdef FLIP_SIDED
350: 
351: 	objectNormal = -objectNormal;
352: 
353: #endif
354: 
355: vec3 transformedNormal = normalMatrix * objectNormal;
356: 
357: #ifndef FLAT_SHADED
358: 	vNormal = normalize( transformedNormal );
359: #endif
360: 
361: vec3 transformed = vec3( position );
362: 
363: #ifdef USE_DISPLACEMENTMAP
364: 
365: 	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );
366: 
367: #endif
368: 
369: #ifdef USE_MORPHTARGETS
370: 
371: 	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
372: 	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
373: 	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
374: 	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];
375: 
376: 	#ifndef USE_MORPHNORMALS
377: 
378: 	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
379: 	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
380: 	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
381: 	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];
382: 
383: 	#endif
384: 
385: #endif
386: 
387: #ifdef USE_SKINNING
388: 
389: 	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
390: 
391: 	vec4 skinned = vec4( 0.0 );
392: 	skinned += boneMatX * skinVertex * skinWeight.x;
393: 	skinned += boneMatY * skinVertex * skinWeight.y;
394: 	skinned += boneMatZ * skinVertex * skinWeight.z;
395: 	skinned += boneMatW * skinVertex * skinWeight.w;
396: 	skinned  = bindMatrixInverse * skinned;
397: 
398: #endif
399: 
400: #ifdef USE_SKINNING
401: 
402: 	vec4 mvPosition = modelViewMatrix * skinned;
403: 
404: #else
405: 
406: 	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );
407: 
408: #endif
409: 
410: gl_Position = projectionMatrix * mvPosition;
411: 
412: #ifdef USE_LOGDEPTHBUF
413: 
414: 	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;
415: 
416: 	#ifdef USE_LOGDEPTHBUF_EXT
417: 
418: 		vFragDepth = 1.0 + gl_Position.w;
419: 
420: #else
421: 
422: 		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;
423: 
424: 	#endif
425: 
426: #endif
427: 	vViewPosition = - mvPosition.xyz;
428: vNormal = normalize( normalMatrix * normal );
429: vUv = uv;
430: #if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )
431: 
432: 	#ifdef USE_SKINNING
433: 
434: 		vec4 worldPosition = modelMatrix * skinned;
435: 
436: 	#else
437: 
438: 		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
439: 
440: 	#endif
441: 
442: #endif
443: 
444: #if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )
445: 
446: 	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
447: 
448: 	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
449: 
450: 	#ifdef ENVMAP_MODE_REFLECTION
451: 
452: 		vReflect = reflect( cameraToVertex, worldNormal );
453: 
454: 	#else
455: 
456: 		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
457: 
458: 	#endif
459: 
460: #endif
461: 
462: #if MAX_SPOT_LIGHTS > 0 || defined( USE_ENVMAP )
463: 
464: 	vWorldPosition = worldPosition.xyz;
465: 
466: #endif
467: 
468: #ifdef USE_SHADOWMAP
469: 
470: 	for ( int i = 0; i < MAX_SHADOWS; i ++ ) {
471: 
472: 			vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;
473: 
474: 	}
475: 
476: #endif
477: }ljklkj" three.js:26549

